# 自定义类型

## 1. 结构体

### 结构体的声明

**结构体的基础知识**

> 结构是一些值得集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

> 在C语言中结构体成员列表可以为空。

**结构体的声明**

```c
struct tag
{
    member-list;
}variable-list;

or

struct tag;//空结构体
```

例如一个学生的结构体：

``` c
struct Stu
{
    char name[20];
    int age;
    char sex[6];
    char id[20];
};
```

**特殊的声明**

在声明结构体的时候可以不完全声明。

例如

```c
//匿名结构体类型

struct {
    int i;
    char c;
    float f;
}x;

struct
{
    int i;
    char c;
    float f;
}a[20], *p;
```

> 匿名的结构体只能当次使用，不能二次使用。
>
> 也就是说，只能在声明的时候在结构体尾部定义出你需要的变量名。

有一个有意思的问题：

```c
p = &x //是否合法？
```

**警告：**编译器会把上面两种声明当成完全不同的两种类型，所以是非法的。

> 就算成员一样，也不行，编译器会认为是两种类型。



### 结构体的自引用

在结构体中包含一个类型为该结构体本身的成员是否可以呢？

```c
struct Node
{
	int data;
	struct Node next;
};//是否可行？
```

答案是不可行的。因为这个结构体还未完成，内存大小还不确定，编译器无法得知需要开辟内存空间的大小，所以编译器会出错。但是定义结构体指针就可以，因为在32位平台下，任何指针的大小都为4个字节。

可以改为：

```c
struct Node
{
    int data;
    struct Node *next;
};
```

**注意：**就算进行了重命名，在自引用时，也要写全名：

```c
typedef struct Node
{
    int data;
    struct Node *next;
}Node;
```



### 结构体变量的定义和初始化

这里介绍一下结构体变量的定义和初始化：

```c
struct Point
{
    int x;
    int y;
}p1;					//声明类型的同时定义变量p1
struct Point p2;		//定义结构体变量p2
struct Point p3 = {1, 2};//定义变量的同时初始化

struct Stu
{
    char name[16];
    int age;
};
struct Stu s = {"Zhang San", 20}; //初始化

struct Node
{
    int data;
    struct Point p;
    struct Node *next;
}n1 = {10, {4, 5}, NULL};	//结构体嵌套初始化

struct Node n2 = {20, {5, 6}, NULL};	//结构体嵌套初始化
```



### 结构体内存对齐

### **请看我前一篇博客！**



### 结构体传参

```c
struct S
{
    int data[1000];
    int num;
};

struct S s = {{1, 2, 3, 4}, 1000};
//结构体传参
void print1(struct S s)
{
    printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S *ps)
{
    printf("%d\n", ps->num);
}

int main(void)
{
    print1(s);	//传结构体
    print2(&s);	//传结构体地址
    
    return 0;
}
```

上面代码的哪个函数好一点呢？

当然是printf2函数，原因：

> 在函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的时候系统开销就会比较大，所以会导致性能下降。

**结论**：结构体传参的时候，要传递结构体的地址，也就是指针。



## 2. 位段

> 位段的使用非常依赖于平台，所以使用位段必须考虑位段的可移植性。

**什么是位段？**

位段的声明与结构体是类似的，但是有两点不同：

> 1. 位段的成员必须是```int 、unsigned int、signed int 或 char```。
>
> 2. 位段的成员名后边有一个冒号和一个数字。
>
>    例如
>
>    ```c
>    struct A
>    {
>        int _a : 2;
>        int _b : 5;
>        int _c : 10;
>        int _d : 30;
>    };
>    ```
>
>    

A就是一个位段类型。那么A的大小是多少呢？

```c
printf("%d\n", sizeof(struct A));
```

![QQ截图20181121194505](C:\Users\dell\Desktop\QQ截图20181121194505.png)

**位段的内存分配**

1. 位段的成员必须是```int 、unsigned int、signed int 或 char```（属于整型家族）类型。
2. 位段的空间上是按照需要以4个字节（```int```）或者一个字节（```char```）的方式来开辟的。
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

举个例子：

```c
struct S
{
    char a : 3;
    char b : 4;
    char c : 5;
    char d : 4;
};

struct S s = { 0 };
s.a = 10;
s.b = 12; 
s.c = 3;
s.d = 4;

printf("%d\n", sizeof(s));
```

它的大小是多少呢？

![QQ截图20181121195310](C:\Users\dell\Desktop\QQ截图20181121195310.png)

那么它的空间是如何开辟的呢？

![QQ截图20181121195503](C:\Users\dell\Desktop\QQ截图20181121195503.png)

**位段的跨平台问题**

> 1. int 位段被当成有符号数还是无符号数是不确定的。
> 2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出现问题。）
> 3. 位段中的成员在内存中从左向右分配还是从右向左分配标准尚未定义。
> 4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的，但是大部分平台采用后者的做法。

**总结**：

> 跟结构相比，位段可以达到同样的效果，但是可以很好地节省空间，但是有跨平台的问题存在。



## 3. 枚举

枚举顾名思义就是一一列举，把可能的取值一一列举。

### 枚举类型的定义

```c
enum Day//星期
{
	Mon,
	Thes,
	Wed,
	Thur,
	Fri,
	Sat,
	Sun
};

enum Sex//性别
{
	Male,
	Female,
	Secret
};
```

以上都是枚举类型，{}中的内容是枚举类型的可能取值，也叫做枚举常量。

这些可能取值都是有值的，默认从0开始，依次递增1，当然定义的时候也可以赋初值。例如

```c
enum Sex//性别
{
	Male = 2,
	Female = 4,
	Secret = 5
};
```

### 枚举的优点

我们明明可以使用```#define ```定义常量，为什么还要使用枚举？

1. 增加代码的可读性和可维护性。
2. 和```#define```定义的标识符比较枚举有类型检查，更加严谨。
3. 防止了命名污染（封装）。
4. 便于调试。
5. 使用方便，一次可以定义多个常量。

### 枚举的使用

```c
enum Color//颜色
{
 RED=1,
 GREEN=2,
 BLUE=4
};
enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
clr = 5;               //ok
```



## 4. 联合（共用体）

### 联合类型的定义

联合也是一种特殊的自定义类型，这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。比如：

```c
//联合类型的声明
union Un
{
	char c;
	int i;
};

//联合定义变量
union Un un;
//计算联合变量的大小
printf("%d\n", sizeof(un));
```

![QQ截图20181121201937](C:\Users\dell\Desktop\QQ截图20181121201937.png)

### 联合的特点

> 联合是公用内存空间，在定义联合变量是编译器会开辟一个联合成员中最大变量的空间，其他成员与之公用，所以上面的大小为4，编译器只开辟了一个整型的大小，为4个字节。

面试题：

> 判断当前计算机的大小端存储

这道题就完美的利用联合可以解决。

```c
union Un
{
	char c;
	int i;
};
int main(void)
{
	union Un un;
	un.i = 1;
	if (1 == un.c)
	{
		printf("小端存储\n");
	}
	else
	{
		printf("大端存储\n");
	}
    
    return 0;
}
```

![QQ截图20181121202557](C:\Users\dell\Desktop\QQ截图20181121202557.png)

### 联合大小的计算

1. 联合的大小至少是最大成员的大小
2. 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍（联合需要内存对齐）。

比如：

```c
union Un1
{
	char c[5];
	int i;
};

union Un2
{
	short s[7];
	int i;
};


printf("%d\n", sizeof(union Un1));
printf("%d\n", sizeof(union Un2));


```

结果如下：

![QQ截图20181121203021](C:\Users\dell\Desktop\QQ截图20181121203021.png)


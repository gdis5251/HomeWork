#  day 12 作业遇到的问题

##  第一题

> 编写函数： 
> unsigned int reverse_bit(unsigned int value); 
> 这个函数的返回值value的二进制位模式从左到右翻转后的值。 

> 如： 
> 在32位机器上25这个值包含下列各位： 
> 00000000000000000000000000011001 
> 翻转后：（2550136832） 
> 10011000000000000000000000000000 
> 程序结果返回： 
> 2550136832   

###   问题

在第一题中，打印的时候遇到了问题

```c
printf("%lld\n", reverse_bit(num));
```

打印的总是一个非常大的数字，而且只有前几位固定，后几位一直是随机值。

经过我的查找和询问，%lld是打印64位有符号整数，但是我的程序是

```c
for (i = 0; i < 32; i++)
	{
		d += change[32 - i - 1] * (long long int)pow(2, i);
	}

	return d;
```

只进行了32次运算，所以只有前几位固定，后几位缺失的编译器进行了随机处理。

###  解决方法

经过一系列的思考和询问，只需要将``` printf("%lld", reverse_bit(num));```  

改为``` printf("%u\n", reverse_bit(num));```即可。

>  %u 为32位无符号整数
>
>
> unsigned int  （unsigned long）
>
> 4字节8位可表达位数：2^32=42 9496 7296  
>
> 范围：0 ～ 42 9496 7295 (42*10^8)  
# C语言文件操作

> 在开始这篇博客之前，我想灌输一个思想：一切皆文件

## 什么是文件？

在程序设计中，我们说的文件一般有两种：程序文件和数据文件。

**程序文件**

> 程序文件包括：源程序文件（后缀为.c）、目标文件（windows环境下后缀为.obj）、可执行程序（windows环境下后缀为.exe）

**数据文件**

> 文件的内容不一定是程序，而是程序运行时读写的数据。比如程序运行需要从中读取数据的文件，或者输出内容的文件。

## 文件名

> 一个文件要有一个唯一的文件标识，以便用户识别和引用。

文件名包含三个部分：**文件路径 + 文件名主干 + 文件后缀**

例如： C:\code\test.c

## 文件类型

根据数据的组织形式，数据文件被称为**文本文件**或者**二进制文件**。

数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是**二进制文件。**

如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。

以ASCII字符的形式存储的文件就是**文本文件。**

## 文件缓冲区

> ANSIC 标准采用“**缓冲文件系统**”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“**文件缓冲区**”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据c编译系统决定。

看了这么一大顿的资料，还是来一点干货吧！

### 缓冲方案

1. 无缓冲。
2. 行缓冲：按行刷新。
3. 全缓冲：只有把缓冲区写满，数据才会缓冲出来。

> 任何缓冲区存在的意义都是为了提升性能。

**那么说了这么多，我们可以不可人为让编译器进行刷新呢？**

当然可以了！

需要调用 函数 ```int fflush(FILE *stream)```

> 一个程序运行起来之后默认会打开3个流
>
> 标准输入、标准输出、标准错误
>
> 对应的FILE指针为：
>
> stdin：通常对应键盘。
>
> stdout：通常对应显示器。
>
> stderr：通常对应显示器。

## 文件的打开和关闭

文件在读写之前应该先**打开文件**，在使用结束之后应该**关闭文件。**

很多人都知道打开文件，可是在结束之后往往会忘记关闭文件。

> 小程序 是没有任何影响的，由于很快程序结束后，会自动关闭， 但是像服务器（会一直运行），多人使用，如果你不关闭的话，别人想要读写就会无法完成 。 不关闭文件会导致（other）无法再次已写的方式打开，以前是连只读的方式都不行 

就像动态创建一块内存，在使用完后，要记得释放一个道理。

**在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。**

> ANSIC规定使用fopen函数来打开文件，fclose函数来关闭文件。

```fopen```和```fclose```的原型为：

```c
FILE *fopen(const char* filename, const char* mode);
int fclose(FILE *stream);
```

```fopen```函数的第二个参数mode都有什么呢？

| 文件使用方式 | 含义                                     | 如果指定文件不存在 |
| ------------ | ---------------------------------------- | ------------------ |
| "r"(只读)    | 为了输入数据，打开一个已经存在的文本文件 | 出错               |
| "w"(只写)    | 为了输出数据，打开一个文本文件           | 建立一个新的文件   |
| "a"(追加)    | 向文本文件尾添加数据                     | 出错               |
| "rb"(只读)   | 为了输入数据，打开一个二进制文件         | 出错               |
| "wb"(只写)   | 为了输出数据，打开一个二进制文件         | 建立一个新的文件   |
| "ab"(追加)   | 向一个二进制文件尾添加数据               | 出错               |
| "r+"(读写)   | 为了读和写，打开一个文本文件             | 出错               |
| "w+"(读写)   | 为了读和写，建立一个新的文件             | 建立一个新的文件   |
| "a+"(读写)   | 打开一个文件，在文件尾进行读写           | 建立一个新的文件   |
| "rb+"(读写)  | 为了读和写打开一个二进制文件             | 出错               |
| "wb+"(读写)  | 为了读和写，新建一个新的二进制文件       | 建立一个新的文件   |
| "ab+"(读写)  | 打开一个二进制文件，在文件尾进行读和写   | 建立一个新的文件   |

举例代码：

```c
int main(void)
{
	int i_num = 12345;
	FILE *fp = fopen("test.txt", "wb");

	if (!fp)
	{
		perror("fopen");
		exit(EXIT_FAILURE);
	}

	fwrite(&i_num, sizeof(int), 1, fp);

	fclose(fp);

	system("pause");
	return 0;
}
```

## 文件的顺序读写

| 功能           | 函数名  | 适用于     |
| -------------- | ------- | ---------- |
| 字符输入函数   | fgetc   | 所有输入流 |
| 字符输出函数   | fputc   | 所有输出流 |
| 文本行输入函数 | fgets   | 所有输入流 |
| 文本行输出函数 | fputs   | 所有输出流 |
| 格式化输入函数 | fscanf  | 所有输入流 |
| 格式化输出函数 | fprintf | 所有输出流 |
| 二进制输入     | fread   | 文件       |
| 二进制输出     | fwrite  | 文件       |

## 文件的随机读写

**fseek**

> 根据文件指针的位置和偏移量来定位文件指针。

```c
int fseek(FILE *stream, long int offset, int origin);
```

这个函数是用来更改当前文件的写入位置的，说白了就是将我光标移到哪，只不过我们看不到。

函数的第一个参数是文件指针，第二个为偏移量，第三个为文件指针的位置。

> 第三个参数有系统定义的宏
>
> SEEK_CUR
>
> 文件指针的当前位置
>
> SEEK_END
>
> 文件的末尾
>
> SEEK_SET
>
> 文件的开头

**ftell**

> 返回文件指针相对于起始位置的偏移量

```c
long int ftell(FILE *stream);
```

这个函数可以配合着fseek来求文件总共有所少个字节，只要先调用fseek函数将文件指针指向文件的末尾，然后在调用ftell来求得值用一个长整型来接收即可。

**rewind**

> 让文件指针的位置回到文件的起始位置

```c
void rewind (FILE *stream);
```

## 文件结束的判定

**被错误使用的feof**

牢记：在文件读取的过程中，不能用**feof**函数的返回值直接判断文件是否结束，而是**应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。**

1. 文本文件读取是否结束，判断返回值是否为EOF(fgetc)，或者NULL(fgets)

   例如：

   - fgetc判断是否为EOF
   - fgets判断返回值是否为NULL

2. 二进制文件的读取结束判断，判断返回值是否小于实际要读的个数

   例如：

   - fread判断返回值是否小于实际要读的个数

正确的使用：

**文本文件：**

```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int c; // 注意：int，非char，要求处理EOF
    FILE* fp = fopen("test.txt", "r");
    if(!fp) 
    {
       	perror("File opening failed");
        return EXIT_FAIL
    }
 	
    //fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF
    while ((c = fgetc(fp)) != EOF) // 标准C I/O读取文件循环
    { 
       putchar(c);
    }
 	
    //判断是什么原因结束的
    if (ferror(fp))
        puts("I/O error when reading");
    else if (feof(fp))
        puts("End of file reached successfully");
    fclose(fp);
}
```

**二进制文件：**

```c
#include <stdio.h>

#define SIZE 5

int main(void)
{
    double a[SIZE] = {1.0,2.0,3.0,4.0,5.0};
    double b[SIZE] = {0.0};
    size_t ret_code = 0;

    FILE *fp = fopen("test.bin", "wb"); // 必须用二进制模式
    fwrite(a, sizeof(*a), SIZE, fp); // 写 double 的数组
    
    fclose(fp);
    
    fp = fopen("test.bin","rb");
    ret_code = fread(b, sizeof *b, SIZE, fp); // 读 double 的数组
    
    if(ret_code == SIZE) {
        puts("Array read successfully, contents: ");
        for(int n = 0; n < SIZE; ++n) printf("%f ", b[n]);
        putchar('\n');
   } else { // error handling
       if (feof(fp))
          printf("Error reading test.bin: unexpected end of file\n");
       else if (ferror(fp)) {
           perror("Error reading test.bin");
       }
   }
    
    fclose(fp);
}
```



















































































